#!/usr/bin/env python3

import argparse

from cilib import file_system, git
from cilib.version import (parse_semver, produce_tag, produce_url,
                           produce_version)
from cilib.version_yaml import *

helpMsg = "This tool reads the version from files and outputs it, with modifications depending on options"


def main():

    # They use different formats but:
    #  - we can just use a YAML parser for both
    #  - both use a "version" field at the root
    #  - both use semver
    # so they can be treated the same
    version_files = {
        "app": "package.json",
        "helm": "charts/connect-frontend/Chart.yaml",
    }

    parser = argparse.ArgumentParser(description=helpMsg)

    parser.add_argument(
        "component",
        choices=version_files.keys(),
    )

    parser.add_argument(
        "output",
        choices=[
            "semver",
            "tag",
            "url",
        ],
        default="semver",
        nargs="?",
        help="version: produce a final version string; tag: same but it's a docker tag; url: same but it's a k8s-compliant URL (what k8s calls DNS-1123)",
    )
    parser.add_argument(
        "--ref",
        help="What git ref to operate on (if not given, a mix of HEAD and the working directory)",
    )
    parser.add_argument(
        "--version", help="Use this SemVer2 string instead of parsing the version file"
    )
    for name, path in version_files.items():
        parser.add_argument(
            f"--{name}-version-file",
            default=path,
            help=f'Path of the file to parse; if --ref is given, from the root of the repo, else a regular FS path. Defaults to "{{project root}}/{path}".',
        )
    parser.add_argument(
        "--max-length",
        type=int,
        help="Max length in characters for tags and URLs; a docker tag can't be over 128, a Common Name for TLS certs 64 usually",
    )
    parser.add_argument(
        "--length-fallback",
        action="store_true",
        help="If the produced tag or URL is too long for --max-length, instead output (prefix-)commit_id(-suffix); commit_id will be as long as possible, but an error will be returned if it is less than 7 characters",
    )
    parser.add_argument(
        "--insert-dev-info",
        action="store_true",
        help="Append info such as commit ID into the prerelease and build metadata fields",
    )

    args = parser.parse_args()
    file_system.set_wd_to_project_root()

    if args.version:
        args.version = parse_semver(args.version)
    else:
        if args.ref:
            args.version = get_version_from_ref(
                args.ref, getattr(args, f"{args.component}_version_file")
            )
        else:
            args.version = get_version_from_path(
                getattr(args, f"{args.component}_version_file")
            )

    to_insert = {
        "prerelease": [],
        "buildmetadata": [],
        "prefix": [],
        "suffix": [],
    }

    if args.insert_dev_info:
        ref = args.ref if args.ref else "HEAD"
        to_insert["buildmetadata"].append({"append": git.short_id(ref)})
        to_insert["prerelease"] += [
            {"prepend": "dev"},
            {"append": f"{git.date(ref):%Y%m%d}"},
        ]

    final_version = produce_version(args.version, to_insert)

    if args.output == "semver":
        print(final_version.semver)
    if args.output == "tag":
        print(
            produce_tag(
                final_version,
                max_length=args.max_length,
                length_fallback=args.length_fallback,
            )
        )
    if args.output == "url":
        print(
            produce_url(
                final_version,
                max_length=args.max_length,
                length_fallback=args.length_fallback,
            )
        )


if __name__ == "__main__":
    main()
